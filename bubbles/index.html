<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Hero</title>
    <!-- Friendly Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@600;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #E0F7FA;
            --primary: #FF6B6B;
            --secondary: #4ECDC4;
            --accent: #FFE66D;
            --text: #2d3436;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Nunito', sans-serif;
            background: radial-gradient(circle at center, #ffffff 0%, #E0F7FA 100%);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 🏠 HOME BUTTON */
        .home-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            text-decoration: none;
            box-shadow: 0 4px 0 #cbd5e1;
            border: 2px solid #e2e8f0;
            z-index: 100;
            transition: transform 0.1s;
        }
        .home-btn:active { transform: translateY(4px); box-shadow: none; }

        /* 🎮 CANVAS */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 📊 HUD */
        .hud {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: none;
        }

        .xp-bar-container {
            width: 200px;
            height: 24px;
            background: rgba(255,255,255,0.8);
            border: 3px solid #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            position: relative;
        }

        .xp-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FFE66D, #FFD93D);
            transition: width 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .level-badge {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            padding: 0 10px;
            font-family: 'Fredoka One', cursive;
            color: #d35400;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            z-index: 2;
        }

        /* 🃏 CARD SELECTION OVERLAY */
        #upgrade-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #upgrade-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .upgrade-title {
            font-family: 'Fredoka One', cursive;
            font-size: 3rem;
            color: var(--primary);
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #fff;
            animation: bounceIn 0.5s;
        }

        .cards-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 900px;
            padding: 20px;
        }

        .card {
            background: #fff;
            width: 220px;
            height: 300px;
            border-radius: 30px;
            border: 6px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            transition: transform 0.2s, border-color 0.2s;
            animation: popIn 0.4s backwards;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: var(--secondary);
        }

        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }

        .card-icon {
            font-size: 5rem;
            filter: drop-shadow(0 4px 0 rgba(0,0,0,0.1));
        }

        .card-name {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            color: var(--text);
            text-align: center;
            line-height: 1.1;
        }

        .card-desc {
            font-size: 1rem;
            color: #636e72;
            text-align: center;
            font-weight: 700;
        }

        /* 👆 START HINT */
        #start-hint {
            position: absolute;
            bottom: 20%;
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            color: rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
            pointer-events: none;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.5); } 50% { transform: scale(1.1); } 100% { transform: scale(1); }
        }
        @keyframes popIn {
            0% { transform: translateY(50px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes pulse {
            0% { opacity: 0.3; transform: scale(1); } 50% { opacity: 0.6; transform: scale(1.05); } 100% { opacity: 0.3; transform: scale(1); }
        }

    </style>
</head>
<body>

    <a href="/" class="home-btn" title="Back to Games">🏠</a>

    <div class="hud">
        <div class="xp-bar-container">
            <div class="level-badge">LVL <span id="lvl-num">1</span></div>
            <div class="xp-bar-fill" id="xp-bar"></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="start-hint">Drag to Move!</div>

    <!-- Upgrade Screen -->
    <div id="upgrade-overlay">
        <div class="upgrade-title">Level Up! 🎉</div>
        <div class="cards-container" id="cards-wrapper">
            <!-- Cards injected here -->
        </div>
    </div>

    <script>
        /**
         * BUBBLE HERO
         * A baby-friendly rogue-like.
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- Game State ---
        let game = {
            active: false,
            paused: false,
            level: 1,
            xp: 0,
            xpToNext: 5,
            width: 0,
            height: 0
        };

        // --- Player ---
        let player = {
            x: 0, y: 0,
            size: 30,
            speed: 5,
            color: '#FF6B6B',
            emoji: '🌟',
            angle: 0,
            // Stats
            fireRate: 60, // Frames between shots
            fireTimer: 0,
            bulletSpeed: 7,
            bulletSize: 12,
            bulletCount: 1, // Multishot
            orbiters: 0
        };

        // --- Entities ---
        let enemies = [];
        let bullets = [];
        let particles = [];
        let gems = [];
        let orbiters = [];

        // --- Config ---
        const ENEMY_SPAWN_RATE = 100; // frames
        let spawnTimer = 0;

        const UPGRADES = [
            { id: 'multishot', name: 'More Bubbles', icon: '🫧', desc: 'Shoot more bubbles at once!', type: 'stat', key: 'bulletCount', val: 1 },
            { id: 'rate', name: 'Fast Fire', icon: '⚡', desc: 'Shoot bubbles faster!', type: 'stat', key: 'fireRate', val: -10, limit: 10 },
            { id: 'size', name: 'Big Bubbles', icon: '🎈', desc: 'Giant bubbles!', type: 'stat', key: 'bulletSize', val: 5 },
            { id: 'speed', name: 'Speedy Star', icon: '👟', desc: 'Move faster!', type: 'stat', key: 'speed', val: 1 },
            { id: 'orbiter', name: 'Moon Shield', icon: '🌙', desc: 'A protective moon friend!', type: 'special' },
            { id: 'pierce', name: 'Tough Bubble', icon: '🏹', desc: 'Bubbles go through enemies!', type: 'stat', key: 'pierce', val: 1 } // Not implemented logic yet, simplified
        ];

        // --- Audio ---
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            if (type === 'shoot') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'pop') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'gem') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'levelup') {
                // Chord
                [440, 554, 659].forEach((freq, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.type = 'triangle';
                    o.frequency.value = freq;
                    g.gain.value = 0.1;
                    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
                    o.connect(g); g.connect(audioCtx.destination);
                    o.start(audioCtx.currentTime + i*0.1);
                    o.stop(audioCtx.currentTime + 1.5);
                });
            }

            osc.connect(gain);
            gain.connect(audioCtx.destination);
        }

        // --- Core Functions ---

        function resize() {
            game.width = canvas.width = window.innerWidth;
            game.height = canvas.height = window.innerHeight;
            if(!game.active) {
                player.x = game.width / 2;
                player.y = game.height / 2;
            }
        }

        function spawnEnemy() {
            // Spawn at edge
            let x, y;
            if(Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -30 : game.width + 30;
                y = Math.random() * game.height;
            } else {
                x = Math.random() * game.width;
                y = Math.random() < 0.5 ? -30 : game.height + 30;
            }

            enemies.push({
                x: x, y: y,
                size: 25 + Math.random() * 10,
                speed: 1 + Math.random() * 1.5, // Slow
                color: '#b2bec3',
                hp: 1 + Math.floor(game.level / 3)
            });
        }

        function fire() {
            playSound('shoot');
            // Multishot logic (Spread)
            for(let i=0; i<player.bulletCount; i++) {
                // Target closest enemy or random if none
                let angle = 0;
                let closest = null;
                let minDist = 9999;
                
                enemies.forEach(e => {
                    const d = Math.hypot(e.x - player.x, e.y - player.y);
                    if(d < minDist) { minDist = d; closest = e; }
                });

                if(closest) {
                    angle = Math.atan2(closest.y - player.y, closest.x - player.x);
                } else {
                    angle = Math.random() * Math.PI * 2;
                }

                // Add spread
                const spread = 0.3; // Radians
                const finalAngle = angle + (i - (player.bulletCount-1)/2) * spread;

                bullets.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(finalAngle) * player.bulletSpeed,
                    vy: Math.sin(finalAngle) * player.bulletSpeed,
                    size: player.bulletSize,
                    life: 100
                });
            }
        }

        function createParticles(x, y, color, count=5) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function checkLevelUp() {
            const pct = (game.xp / game.xpToNext) * 100;
            document.getElementById('xp-bar').style.width = `${pct}%`;

            if(game.xp >= game.xpToNext) {
                game.xp = 0;
                game.xpToNext = Math.floor(game.xpToNext * 1.5);
                game.level++;
                document.getElementById('lvl-num').textContent = game.level;
                document.getElementById('xp-bar').style.width = '0%';
                
                showLevelUp();
            }
        }

        function showLevelUp() {
            game.paused = true;
            playSound('levelup');
            
            const container = document.getElementById('cards-wrapper');
            container.innerHTML = '';
            
            // Pick 3 random upgrades
            const options = [];
            while(options.length < 3) {
                const pick = UPGRADES[Math.floor(Math.random() * UPGRADES.length)];
                if(!options.includes(pick)) options.push(pick);
            }

            options.forEach(opt => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <div class="card-icon">${opt.icon}</div>
                    <div class="card-name">${opt.name}</div>
                    <div class="card-desc">${opt.desc}</div>
                `;
                card.onclick = () => applyUpgrade(opt);
                container.appendChild(card);
            });

            document.getElementById('upgrade-overlay').classList.add('active');
        }

        function applyUpgrade(opt) {
            if(opt.type === 'stat') {
                if(opt.key === 'fireRate') {
                    player.fireRate = Math.max(opt.limit || 5, player.fireRate + opt.val);
                } else {
                    player[opt.key] += opt.val;
                }
            } else if (opt.type === 'special') {
                if(opt.id === 'orbiter') {
                    player.orbiters++;
                    orbiters.push({angle: (Math.PI*2/player.orbiters) * orbiters.length, dist: 60});
                    // Rebalance angles
                    orbiters.forEach((o, i) => o.angle = (Math.PI*2/player.orbiters) * i);
                }
            }

            document.getElementById('upgrade-overlay').classList.remove('active');
            game.paused = false;
        }

        // --- Game Loop ---

        function update() {
            if(game.paused) {
                requestAnimationFrame(update);
                return;
            }

            // Player Auto-Fire
            player.fireTimer++;
            if(player.fireTimer > player.fireRate) {
                fire();
                player.fireTimer = 0;
            }

            // Update Bullets
            for(let i=0; i<bullets.length; i++) {
                let b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                if(b.life <= 0 || b.x < 0 || b.x > game.width || b.y < 0 || b.y > game.height) {
                    bullets.splice(i, 1); i--;
                }
            }

            // Update Orbiters
            orbiters.forEach(o => {
                o.angle += 0.05;
            });

            // Update Enemies
            spawnTimer++;
            if(spawnTimer > Math.max(20, ENEMY_SPAWN_RATE - (game.level * 2))) {
                spawnEnemy();
                spawnTimer = 0;
            }

            for(let i=0; i<enemies.length; i++) {
                let e = enemies[i];
                // Move towards player
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;

                // Collision with Bullets
                for(let j=0; j<bullets.length; j++) {
                    let b = bullets[j];
                    const dist = Math.hypot(e.x - b.x, e.y - b.y);
                    if(dist < e.size + b.size) {
                        // HIT
                        e.hp--;
                        bullets.splice(j, 1); j--; // Remove bullet
                        playSound('pop');
                        
                        if(e.hp <= 0) {
                            // Die
                            createParticles(e.x, e.y, e.color, 8);
                            gems.push({x: e.x, y: e.y, vy: -5}); // Drop gem
                            enemies.splice(i, 1); i--;
                        } else {
                            // Hurt effect (knockback)
                            e.x -= Math.cos(angle) * 10;
                            e.y -= Math.sin(angle) * 10;
                        }
                        break;
                    }
                }

                // Collision with Orbiters
                orbiters.forEach(o => {
                    const ox = player.x + Math.cos(o.angle) * o.dist;
                    const oy = player.y + Math.sin(o.angle) * o.dist;
                    const dist = Math.hypot(e.x - ox, e.y - oy);
                    if(dist < e.size + 15) {
                        e.hp = 0; // Instakill
                        createParticles(e.x, e.y, '#FFE66D', 10);
                        gems.push({x: e.x, y: e.y, vy: -5});
                        enemies.splice(i, 1); i--;
                    }
                });
            }

            // Update Gems
            for(let i=0; i<gems.length; i++) {
                let g = gems[i];
                // Magnet effect
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if(dist < 150) {
                    g.x += (player.x - g.x) * 0.1;
                    g.y += (player.y - g.y) * 0.1;
                }
                
                if(dist < player.size + 10) {
                    game.xp++;
                    playSound('gem');
                    checkLevelUp();
                    gems.splice(i, 1); i--;
                }
            }

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, game.width, game.height);

            // Draw Gems
            gems.forEach(g => {
                ctx.font = "20px Arial";
                ctx.fillText("💎", g.x - 10, g.y + 5);
            });

            // Draw Particles
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) particles.splice(i, 1);
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            // Draw Bullets
            ctx.fillStyle = '#4BCFFA';
            bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
                ctx.fill();
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.beginPath();
                ctx.arc(b.x - b.size*0.3, b.y - b.size*0.3, b.size/3, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#4BCFFA';
            });

            // Draw Enemies (Dust Bunnies)
            enemies.forEach(e => {
                ctx.fillStyle = e.color;
                ctx.beginPath();
                // Wobbly circle
                ctx.arc(e.x, e.y, e.size, 0, Math.PI*2);
                ctx.fill();
                // Eyes
                ctx.fillStyle = '#2d3436';
                ctx.beginPath();
                ctx.arc(e.x - 8, e.y - 2, 3, 0, Math.PI*2);
                ctx.arc(e.x + 8, e.y - 2, 3, 0, Math.PI*2);
                ctx.fill();
            });

            // Draw Player
            // Orbiters
            orbiters.forEach(o => {
                const ox = player.x + Math.cos(o.angle) * o.dist;
                const oy = player.y + Math.sin(o.angle) * o.dist;
                ctx.font = "20px Arial";
                ctx.fillText("🌙", ox - 10, oy + 5);
            });

            // Star
            ctx.font = `${player.size * 2}px Arial`;
            ctx.fillText(player.emoji, player.x - player.size, player.y + player.size/2);
        }

        // --- Inputs ---
        let isDragging = false;

        // Target Logic
        let targetX = 0;
        let targetY = 0;

        function handleInput(x, y) {
            document.getElementById('start-hint').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            // Lerp towards finger
            // Simple: Update target, Loop handles movement (actually loop logic needs to update position)
            // Let's do simple direct move with lag in update? 
            // Or just set position? Direct feels responsive for babies.
            // Let's use Lerp in update loop for smoothness.
            targetX = x;
            targetY = y;
            game.active = true;
        }

        // Hook movement into update loop
        const originalUpdate = update;
        update = function() {
            if(game.active && !game.paused) {
                // Smooth move player towards target
                const dx = targetX - player.x;
                const dy = targetY - player.y;
                const dist = Math.hypot(dx, dy);
                
                if(dist > 1) {
                    player.x += dx * 0.1; // 0.1 ease factor
                    player.y += dy * 0.1;
                }
            }
            originalUpdate();
        }

        window.addEventListener('mousedown', e => {
            isDragging = true;
            handleInput(e.clientX, e.clientY);
        });
        window.addEventListener('mousemove', e => {
            if(isDragging) handleInput(e.clientX, e.clientY);
        });
        window.addEventListener('mouseup', () => isDragging = false);

        window.addEventListener('touchstart', e => {
            isDragging = true;
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        window.addEventListener('touchmove', e => {
            if(isDragging) {
                e.preventDefault();
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});
        window.addEventListener('touchend', () => isDragging = false);

        window.addEventListener('resize', resize);
        
        // Start center
        resize();
        targetX = player.x;
        targetY = player.y;
        update();

    </script>
</body>
</html>