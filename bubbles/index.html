<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Hero</title>
    <!-- Friendly Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@600;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #E0F7FA;
            --primary: #FF6B6B;
            --secondary: #4ECDC4;
            --accent: #FFE66D;
            --text: #2d3436;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Nunito', sans-serif;
            background: radial-gradient(circle at center, #ffffff 0%, #E0F7FA 100%);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 🏠 HOME BUTTON */
        .home-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            text-decoration: none;
            box-shadow: 0 4px 0 #cbd5e1;
            border: 2px solid #e2e8f0;
            z-index: 100;
            transition: transform 0.1s;
        }
        .home-btn:active { transform: translateY(4px); box-shadow: none; }

        /* 🎮 CANVAS */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 📊 HUD */
        .hud {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            pointer-events: none;
            z-index: 10;
        }

        .bar-container {
            width: 220px;
            height: 28px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #fff;
            border-radius: 14px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #hp-bar { background: linear-gradient(90deg, #ff7675, #d63031); }
        #xp-bar { background: linear-gradient(90deg, #FFE66D, #FFD93D); width: 0%; }

        .bar-badge {
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            padding: 2px 8px;
            border-radius: 10px;
            font-family: 'Fredoka One', cursive;
            color: white;
            font-size: 0.8rem;
            z-index: 2;
        }
        
        .bar-text {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-family: 'Fredoka One', cursive;
            color: #2d3436;
            font-size: 0.9rem;
            z-index: 2;
            text-shadow: 0 1px 0 rgba(255,255,255,0.5);
        }

        .hp-badge { background: #d63031; }
        .xp-badge { background: #f1c40f; color: #7f6000; }

        /* ⚡ POWER UP INDICATORS */
        .stats-panel {
            position: absolute;
            top: 90px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .stat-item {
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(4px);
            padding: 5px 10px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Fredoka One', cursive;
            color: #636e72;
            font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            transform: translateX(-100px);
            animation: slideIn 0.3s forwards;
        }
        
        .stat-icon { font-size: 1.2rem; }

        @keyframes slideIn { to { transform: translateX(0); } }

        /* 🃏 OVERLAYS */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.active { opacity: 1; pointer-events: auto; }

        .overlay-title {
            font-family: 'Fredoka One', cursive;
            font-size: 3.5rem;
            color: var(--primary);
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #fff;
            text-align: center;
            animation: bounceIn 0.5s;
        }

        /* Level Up Cards */
        .cards-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
            padding: 20px;
        }

        .card {
            background: #fff;
            width: 220px;
            height: 300px;
            border-radius: 30px;
            border: 6px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            transition: transform 0.2s, border-color 0.2s;
            animation: popIn 0.4s backwards;
        }

        .card:hover { transform: translateY(-10px) scale(1.05); border-color: var(--secondary); }
        .card:active { transform: scale(0.95); }

        .card-icon-img {
            width: 90px;
            height: 90px;
            object-fit: contain;
            margin-bottom: 10px;
        }

        .card-name {
            font-family: 'Fredoka One', cursive;
            font-size: 1.4rem;
            color: var(--text);
            text-align: center;
        }

        .card-desc {
            font-size: 1rem;
            color: #636e72;
            text-align: center;
            font-weight: 700;
        }

        /* Game Over Buttons */
        .restart-btn {
            background: var(--secondary);
            color: white;
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 0 #2aa198;
            transition: transform 0.1s;
        }
        .restart-btn:active { transform: translateY(6px); box-shadow: none; }

        /* Boss Warning */
        #boss-warning {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-family: 'Fredoka One', cursive;
            font-size: 4rem;
            color: #d63031;
            text-shadow: 2px 2px 0 white;
            pointer-events: none;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.5s;
        }
        #boss-warning.show { opacity: 1; transform: scale(1); animation: pulseRed 1s infinite; }

        @keyframes bounceIn { 0% { transform: scale(0.5); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes popIn { 0% { transform: translateY(50px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
        @keyframes pulseRed { 0% { color: #d63031; } 50% { color: #ff7675; transform: scale(1.1); } 100% { color: #d63031; } }

    </style>
</head>
<body id="gameBody">

    <a href="/" class="home-btn" title="Back to Games">🏠</a>

    <div class="hud">
        <div class="bar-container">
            <div class="bar-badge hp-badge">HP</div>
            <div class="bar-fill" id="hp-bar"></div>
            <span class="bar-text" id="hp-text">100/100</span>
        </div>
        <div class="bar-container">
            <div class="bar-badge xp-badge">LVL <span id="lvl-num">1</span></div>
            <div class="bar-fill" id="xp-bar"></div>
            <span class="bar-text" id="xp-text">0/5</span>
        </div>
    </div>

    <!-- Power Up Status Panel -->
    <div class="stats-panel" id="stats-panel">
        <!-- Injected JS -->
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="boss-warning">⚠️ BOSS! ⚠️</div>
    <div id="start-hint" style="position:absolute; bottom:20%; width:100%; text-align:center; font-family:'Fredoka One'; font-size:2rem; color:rgba(0,0,0,0.3); pointer-events:none; animation:pulse 2s infinite">Drag to Move!</div>

    <!-- Level Up Screen -->
    <div id="upgrade-overlay" class="overlay">
        <div class="overlay-title">Level Up! 🎉</div>
        <div class="cards-container" id="cards-wrapper"></div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-overlay" class="overlay">
        <div class="overlay-title" style="color:#ff7675">Oh no! 🤕</div>
        <div style="font-size:1.5rem; color:#636e72; margin-bottom:30px; font-weight:700">You reached Level <span id="final-level">1</span></div>
        <button class="restart-btn" onclick="restartGame()">Try Again</button>
    </div>

    <script>
        /**
         * BUBBLE HERO v6.4
         * - Damage Scaling
         * - Luck System (Multi-drops)
         * - XP Numeric Display
         * - Safe Deletion Fix
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ASSET_PATH = '../assets/badges1/';
        const body = document.getElementById('gameBody');

        // --- Assets for upgrades ---
        // (Enemies are vector now, but upgrades use images)
        
        // --- Game State ---
        let game = {
            active: false,
            paused: false,
            level: 1,
            xp: 0,
            xpToNext: 5,
            width: window.innerWidth,
            height: window.innerHeight,
            bossMode: false,
            time: 0
        };

        let player = {
            x: game.width / 2,
            y: game.height / 2,
            size: 35,
            speed: 5,
            color: '#FF6B6B',
            emoji: '🌟',
            hp: 100,
            maxHp: 100,
            // Stats
            damage: 1,
            luck: 0,
            fireRate: 60,
            fireTimer: 0,
            bulletSpeed: 7,
            bulletSize: 15,
            bulletCount: 1,
            pierce: 0,
            orbiters: 0
        };

        let enemies = [];
        let bullets = [];
        let particles = [];
        let gems = [];
        let orbiters = [];
        let targetX = player.x;
        let targetY = player.y;

        // --- Config ---
        const BASE_SPAWN_RATE = 100;
        let spawnTimer = 0;

        const UPGRADES = [
            { id: 'multishot', name: 'More Bubbles', img: 'beer_t.png', desc: 'Shoot +1 bubble!', type: 'stat', key: 'bulletCount', val: 1 },
            { id: 'rate', name: 'Fast Fire', img: 'arrow_s_t.jpg', desc: 'Shoot faster!', type: 'stat', key: 'fireRate', val: -10, limit: 10 },
            { id: 'size', name: 'Big Bubbles', img: 'bag_t.png', desc: 'Big & Strong bubbles!', type: 'stat', key: 'bulletSize', val: 5, dmg: 1 },
            { id: 'pierce', name: 'Tough Bubble', img: 'anvil_t.png', desc: 'Pierce & Damage Up!', type: 'stat', key: 'pierce', val: 1, dmg: 0.5 },
            { id: 'orbiter', name: 'Moon Shield', img: 'armor_t.jpg', desc: 'Protective moon!', type: 'special' },
            { id: 'speed', name: 'Speedy Star', img: 'baner_t.png', desc: 'Move faster!', type: 'stat', key: 'speed', val: 1 },
            { id: 'heal', name: 'Yummy Heart', img: 'book_t.jpg', desc: 'Heal 50 HP!', type: 'heal', val: 50 },
            { id: 'maxhp', name: 'Big Heart', img: 'heart_t.png', desc: 'Max HP +50!', type: 'maxhp', val: 50 },
            { id: 'luck', name: 'Lucky Charm', img: 'trinket_t.png', desc: 'Find more gems!', type: 'stat', key: 'luck', val: 1 }
        ];

        // --- Audio ---
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            if (type === 'shoot') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'pop') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'gem') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            }

            osc.connect(gain);
            gain.connect(audioCtx.destination);
        }

        // --- Logic ---
        function spawnEnemy() {
            let x, y;
            if(Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -40 : game.width + 40;
                y = Math.random() * game.height;
            } else {
                x = Math.random() * game.width;
                y = Math.random() < 0.5 ? -40 : game.height + 40;
            }

            // Enemy Scaling Logic
            let hp = 1 + Math.floor(game.level / 3);
            let speed = 1 + Math.random() * 1.5;
            let color = '#b2bec3';
            let size = 30 + Math.random() * 10;
            let type = 1;

            if (game.level >= 2 && Math.random() > 0.6) {
                hp += 2; color = '#636e72'; size += 5; type = 2;
            }
            if (game.level >= 4 && Math.random() > 0.8) {
                speed += 1.5; color = '#ff7675'; size -= 5; type = 3;
            }

            enemies.push({
                x: x, y: y,
                size: size,
                speed: speed,
                hp: hp,
                maxHp: hp,
                color: color,
                angle: 0,
                type: type,
                isBoss: false,
                dead: false
            });
        }

        function spawnBoss() {
            game.bossMode = true;
            const warning = document.getElementById('boss-warning');
            warning.classList.add('show');
            setTimeout(() => warning.classList.remove('show'), 3000);
            
            // Boss HP scales significantly
            const bossHp = 50 + (game.level * 15); 

            enemies.push({
                x: game.width / 2, 
                y: -150,
                size: 90,
                speed: 1.2 + (game.level * 0.05),
                hp: bossHp,
                maxHp: bossHp,
                color: '#d63031', // Boss Red
                angle: 0,
                isBoss: true,
                dead: false
            });
        }

        function fire() {
            playSound('shoot');
            for(let i=0; i<player.bulletCount; i++) {
                let angle = 0;
                let closest = null;
                let minDist = 9999;
                
                enemies.forEach(e => {
                    if (e.dead) return;
                    const d = Math.hypot(e.x - player.x, e.y - player.y);
                    if(d < minDist) { minDist = d; closest = e; }
                });

                if(closest) {
                    angle = Math.atan2(closest.y - player.y, closest.x - player.x);
                } else {
                    angle = Math.random() * Math.PI * 2;
                }

                const spread = 0.3;
                const finalAngle = angle + (i - (player.bulletCount-1)/2) * spread;

                bullets.push({
                    x: player.x, y: player.y,
                    vx: Math.cos(finalAngle) * player.bulletSpeed,
                    vy: Math.sin(finalAngle) * player.bulletSpeed,
                    size: player.bulletSize,
                    damage: player.damage,
                    life: 300, // Longer life for infinite feel
                    pierceCount: player.pierce,
                    hitList: []
                });
            }
        }

        function update() {
            // Always draw to avoid black screen
            draw();

            if(game.paused) {
                requestAnimationFrame(update);
                return;
            }

            game.time += 0.05;

            // --- Movement ---
            if(game.active) {
                const dx = targetX - player.x;
                const dy = targetY - player.y;
                const dist = Math.hypot(dx, dy);
                if(dist > 1) {
                    player.x += dx * 0.08;
                    player.y += dy * 0.08;
                    
                    // Boundaries
                    player.x = Math.max(player.size, Math.min(game.width - player.size, player.x));
                    player.y = Math.max(player.size, Math.min(game.height - player.size, player.y));
                }

                player.fireTimer++;
                if(player.fireTimer > player.fireRate) {
                    fire();
                    player.fireTimer = 0;
                }
            }

            // Spawn
            spawnTimer++;
            const rate = game.bossMode ? BASE_SPAWN_RATE * 1.5 : Math.max(20, BASE_SPAWN_RATE - (game.level * 2));
            if(spawnTimer > rate) {
                spawnEnemy();
                spawnTimer = 0;
            }

            // Update Bullets
            for(let i=0; i<bullets.length; i++) {
                let b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                if(b.life <= 0) { bullets.splice(i, 1); i--; }
            }

            // Update Enemies & Collision
            enemies.forEach(e => {
                if(e.dead) return;
                
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                e.x += Math.cos(angle) * e.speed;
                e.y += Math.sin(angle) * e.speed;
                if(e.isBoss) e.angle += 0.02;

                const distPlayer = Math.hypot(player.x - e.x, player.y - e.y);
                if(distPlayer < player.size + e.size - 10) {
                    player.hp -= 0.5;
                    updateUI();
                    if(player.hp <= 0) triggerGameOver();
                }

                bullets.forEach(b => {
                    if (b.hitList && b.hitList.includes(e)) return;
                    const dist = Math.hypot(e.x - b.x, e.y - b.y);
                    if(dist < e.size + b.size) {
                        e.hp -= b.damage; // Use damage stat
                        playSound('pop');
                        
                        if (b.pierceCount > 0) {
                            b.pierceCount--;
                            b.hitList.push(e);
                        } else {
                            b.life = 0;
                        }
                        
                        if(e.hp <= 0) {
                            killEnemy(e);
                        } else {
                            e.x -= Math.cos(angle) * 15;
                            e.y -= Math.sin(angle) * 15;
                        }
                    }
                });
            });

            enemies = enemies.filter(e => !e.dead);

            for(let i=0; i<gems.length; i++) {
                let g = gems[i];
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if(dist < 150) {
                    g.x += (player.x - g.x) * 0.15;
                    g.y += (player.y - g.y) * 0.15;
                }
                if(dist < player.size + 10) {
                    game.xp += (g.val || 1);
                    playSound('gem');
                    checkLevelUp();
                    gems.splice(i, 1); i--;
                }
            }
            
            for(let i=0; i<particles.length; i++) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) { particles.splice(i, 1); i--; }
            }

            requestAnimationFrame(update);
        }

        function killEnemy(e) {
            e.dead = true;
            createParticles(e.x, e.y, '#b2bec3', 8);
            
            if(e.isBoss) {
                game.bossMode = false;
                gems.push({x: e.x, y: e.y, val: game.xpToNext, size: 30, color: '#FFD700'}); 
                body.classList.add('shake');
                setTimeout(()=>body.classList.remove('shake'), 500);
                createParticles(e.x, e.y, '#FF6B6B', 50);
            } else {
                // Luck / Loot Logic
                let drops = 1;
                if (Math.random() < (0.05 + player.luck * 0.1)) {
                    drops += Math.floor(Math.random() * 2) + 1; 
                }
                
                for(let i=0; i<drops; i++) {
                    gems.push({x: e.x + (Math.random()*20-10), y: e.y + (Math.random()*20-10), val: 1});
                }
            }
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 8 + 3
                });
            }
        }

        function draw() {
            ctx.clearRect(0, 0, game.width, game.height);

            gems.forEach(g => {
                ctx.font = g.size ? "50px Arial" : "24px Arial";
                ctx.fillText("💎", g.x - (g.size ? 20 : 12), g.y + 8);
            });

            ctx.fillStyle = '#4BCFFA';
            bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
                ctx.fill();
            });

            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                if(e.isBoss) ctx.rotate(e.angle); 
                
                if(e.isBoss) {
                    // Vector Boss (Spiky Shape)
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    const spikes = 12;
                    const outerRadius = e.size;
                    const innerRadius = e.size / 2;
                    for(let i=0; i<spikes*2; i++){
                        const r = (i%2 === 0) ? outerRadius : innerRadius;
                        const a = (Math.PI * i) / spikes;
                        ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Boss Eyes
                    ctx.fillStyle = '#2d3436';
                    ctx.beginPath();
                    ctx.arc(-20, -10, 10, 0, Math.PI*2);
                    ctx.arc(20, -10, 10, 0, Math.PI*2);
                    ctx.fill();
                } else if (e.type === 2) { // Tank - Hexagon
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        ctx.lineTo(e.size * Math.cos(i * Math.PI / 3), e.size * Math.sin(i * Math.PI / 3));
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#2d3436';
                    ctx.beginPath(); ctx.arc(-10, -5, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(10, -5, 4, 0, Math.PI*2); ctx.fill();
                } else if (e.type === 3) { // Rusher - Triangle
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    ctx.moveTo(e.size, 0);
                    ctx.lineTo(-e.size/2, e.size/2);
                    ctx.lineTo(-e.size/2, -e.size/2);
                    ctx.fill();
                    // One cyclops eye
                    ctx.fillStyle = '#2d3436';
                    ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
                } else {
                    // Normal - Circle
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, e.size, 0, Math.PI*2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#2d3436';
                    ctx.beginPath(); ctx.arc(-10, -5, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(10, -5, 4, 0, Math.PI*2); ctx.fill();
                    
                    if(Math.sin(game.time * 2 + e.y) > 0.95) {
                         ctx.fillStyle = e.color; 
                         ctx.fillRect(-12, -7, 24, 6);
                    }
                    
                    // Type distinction visuals
                    if(e.type === 3) { // Fast Red
                        ctx.fillStyle = 'rgba(255,0,0,0.3)';
                        ctx.beginPath(); ctx.arc(0, 0, e.size + 4, 0, Math.PI*2); ctx.fill();
                    }
                }
                ctx.restore();

                // HP Bar
                const barW = e.size * 2;
                const barH = 6;
                const pct = e.hp / e.maxHp;
                
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(e.x - e.size, e.y - e.size - 12, barW, barH);
                ctx.fillStyle = pct > 0.5 ? '#2ecc71' : '#ff7675';
                ctx.fillRect(e.x - e.size, e.y - e.size - 12, barW * pct, barH);
            });

            // Player Orbiters
            orbiters.forEach(o => {
                const ox = player.x + Math.cos(o.angle) * 70;
                const oy = player.y + Math.sin(o.angle) * 70;
                ctx.font = "24px Arial";
                ctx.fillText("🌙", ox - 12, oy + 8);
            });

            ctx.font = `${player.size * 2}px Arial`;
            ctx.fillText(player.emoji, player.x - player.size, player.y + player.size/2);
            
            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }

        // --- UI & Helpers ---
        function checkLevelUp() {
            updateUI();
            if(game.xp >= game.xpToNext) {
                game.xp = 0;
                game.xpToNext = Math.floor(game.xpToNext * 1.5);
                game.level++;
                updateUI();
                
                if (game.level % 5 === 0) spawnBoss();
                else showLevelUp();
            }
        }

        function updateUI() {
            const xpPct = Math.min(100, (game.xp / game.xpToNext) * 100);
            const hpPct = Math.min(100, (player.hp / player.maxHp) * 100);
            document.getElementById('xp-bar').style.width = `${xpPct}%`;
            document.getElementById('hp-bar').style.width = `${hpPct}%`;
            document.getElementById('lvl-num').textContent = game.level;
            document.getElementById('hp-text').textContent = `${Math.ceil(player.hp)}/${player.maxHp}`;
            document.getElementById('xp-text').textContent = `${game.xp}/${game.xpToNext}`;
        }

        function updateStatsUI() {
            const panel = document.getElementById('stats-panel');
            panel.innerHTML = '';
            const stats = [
                { icon: '🫧', text: `x${player.bulletCount}` },
                { icon: '🌙', text: `x${player.orbiters}` },
                { icon: '🏹', text: `x${player.pierce}` },
                { icon: '⚔️', text: `${player.damage}` },
                { icon: '🍀', text: `${player.luck}` }
            ];
            stats.forEach(s => {
                if(s.text === 'x0' || s.text === '0') return;
                const div = document.createElement('div');
                div.className = 'stat-item';
                div.innerHTML = `<span class="stat-icon">${s.icon}</span> ${s.text}`;
                panel.appendChild(div);
            });
        }

        function showLevelUp() {
            game.paused = true;
            const container = document.getElementById('cards-wrapper');
            container.innerHTML = '';
            
            let availableUpgrades = UPGRADES.filter(u => {
                if(u.type === 'heal') return player.hp < player.maxHp; 
                if(u.type === 'maxhp') return player.hp >= player.maxHp; // Encourage maxhp if full
                return true;
            });
            
            const options = [];
            while(options.length < 3) {
                const pick = availableUpgrades[Math.floor(Math.random() * availableUpgrades.length)];
                if(!options.includes(pick)) options.push(pick);
            }

            options.forEach(opt => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <img src="${ASSET_PATH + opt.img}" class="card-icon-img">
                    <div class="card-name">${opt.name}</div>
                    <div class="card-desc">${opt.desc}</div>
                `;
                card.onclick = () => applyUpgrade(opt);
                container.appendChild(card);
            });
            document.getElementById('upgrade-overlay').classList.add('active');
        }

        function applyUpgrade(opt) {
            if(opt.type === 'stat') {
                if(opt.key === 'fireRate') player.fireRate = Math.max(5, player.fireRate + opt.val);
                else player[opt.key] += opt.val;
            } else if (opt.type === 'special') {
                if(opt.id === 'orbiter') {
                    player.orbiters++;
                    orbiters.push({angle: 0});
                    orbiters.forEach((o, i) => o.angle = (Math.PI*2/player.orbiters) * i);
                }
            } else if (opt.type === 'heal') {
                player.hp = Math.min(player.maxHp, player.hp + opt.val);
            } else if (opt.type === 'maxhp') {
                player.maxHp += opt.val;
                player.hp += opt.val;
            }

            if (opt.dmg) player.damage += opt.dmg;

            updateStatsUI();
            updateUI();
            document.getElementById('upgrade-overlay').classList.remove('active');
            game.paused = false;
        }

        function triggerGameOver() {
            game.paused = true;
            document.getElementById('final-level').textContent = game.level;
            document.getElementById('game-over-overlay').classList.add('active');
        }

        function restartGame() {
            game.level = 1; game.xp = 0; game.xpToNext = 5; game.paused = false; game.bossMode = false;
            player.hp = 100; player.maxHp = 100; player.bulletCount = 1; player.fireRate = 60; 
            player.bulletSize = 15; player.pierce = 0; player.orbiters = 0; player.damage = 1; player.luck = 0;
            orbiters = []; enemies = []; bullets = []; gems = [];
            document.getElementById('game-over-overlay').classList.remove('active');
            updateUI(); updateStatsUI();
        }

        // --- Inputs ---
        function handleInput(x, y) {
            document.getElementById('start-hint').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
            targetX = x; targetY = y;
            game.active = true;
        }

        window.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => { if(game.active) handleInput(e.clientX, e.clientY); });
        window.addEventListener('touchstart', e => handleInput(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
        window.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            game.width = canvas.width;
            game.height = canvas.height;
            if (!game.active) {
                player.x = game.width / 2;
                player.y = game.height / 2;
                targetX = player.x;
                targetY = player.y;
            }
        }

        window.addEventListener('resize', resize);
        resize();
        update();

    </script>
</body>
</html>